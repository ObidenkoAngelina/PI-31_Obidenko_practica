<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Симуляция растительного сообщества</title>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<style>
    #app {
        font-family: Arial, sans-serif;
        margin: 20px;
        position: relative;
    }
    .simulation-area {
        width: 600px;
        height: 400px;
        border: 2px solid #2c3e50;
        position: relative;
        margin-bottom: 20px;
        transition: background-color 1s ease;
        overflow: hidden;
    }
    .plant {
        position: absolute;
        border-radius: 50%;
        opacity: 0.8;
        transition: all 0.5s ease;
        cursor: pointer;
    }
    .plant::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: clamp(20px, 50%, calc(100% - 20px));
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: pre;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 100;
        pointer-events: none;
        min-width: 120px;
        text-align: center;
    }
    .plant:hover::after {
        visibility: visible;
        opacity: 1;
    }
    .controls {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }
    button {
        padding: 8px 16px;
        cursor: pointer;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        transition: background 0.2s;
    }
    button:hover {
        background: #2980b9;
    }
    button:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }
    .stats {
        margin-top: 20px;
        font-size: 16px;
    }
    h1 {
        color: #2c3e50;
    }
    .season-display {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 18px;
    }
    .winter { background-color: #d4f1f9; }
    .spring { background-color: #e8f8f5; }
    .summer { background-color: #e8f8c1; }
    .autumn { background-color: #fdebd0; }
    .dying {
        animation: fadeOut 2s infinite alternate;
    }
    .winter-sleep {
        opacity: 0.5;
        filter: grayscale(30%);
    }
    @keyframes fadeOut {
        from { opacity: 0.8; }
        to { opacity: 0.3; }
    }
</style>
</head>
<body>
<div id="app">
    <h1>Симуляция растительного сообщества</h1>
    
    <div class="controls">
        <button @click="addPlant">Добавить растение</button>
        <button @click="simulateDay">Симуляция 1 дня</button>
        <button @click="startSimulation" :disabled="isSimulating">Старт</button>
        <button @click="stopSimulation" :disabled="!isSimulating">Стоп</button>
        <button @click="reset">Сброс</button>
        <button @click="changeSpeed">Скорость: {{speed}}x</button>
    </div>
    
    <div class="season-display">
        Год: {{ year }}, Сезон: {{ season }} (День {{ dayInSeason }}/{{ seasonLength }})
    </div>
    
    <div class="simulation-area" :class="season.toLowerCase()" ref="simulationArea">
        <div 
            v-for="plant in plants" 
            :key="plant.id"  
            class="plant"
            :class="{ 
                dying: plant.isDying,
                'winter-sleep': (plant.type === 'Tree' || plant.type === 'Bush') && season === 'Winter'
            }"
            :data-tooltip="getPlantTooltip(plant)"
            :style="{
                left: plant.x + 'px',
                top: plant.y + 'px',
                width: plant.size + 'px',
                height: plant.size + 'px',
                backgroundColor: plant.color,
                zIndex: (plant.type === 'Flower' || plant.type === 'Grass') ? 1 : 3,
                opacity: plant.isDormant ? 0.5 : 0.8
            }"
        ></div>
    </div>
    
    <div class="stats">
        <p>День: {{ totalDays }} ({{ season }})</p>
        <p>Растений: {{ plants.length }} (Активных: {{ activePlantsCount }})</p>
        <p v-if="season === 'Autumn'">Осеннее увядание: {{ autumnDecayRate.toFixed(2) }}% в день</p>
    </div>
</div>

<script>
const { createApp, ref, computed, onMounted } = Vue;

createApp({
    setup() {
        const simulationArea = ref(null);
        const plants = ref([]);
        const deadPlantsMemory = ref([]);
        const day = ref(0);
        const year = ref(1);
        const isSimulating = ref(false);
        let simulationInterval = null;
        const autumnDecayRate = ref(0);
        const speed = ref(1);
        const speedOptions = [1, 2, 5, 10];
        
        const seasons = [
            { name: 'Spring', length: 90, canGrow: ['Tree', 'Bush', 'Flower', 'Grass'] },
            { name: 'Summer', length: 90, canGrow: ['Tree', 'Bush', 'Flower', 'Grass'] },
            { name: 'Autumn', length: 90, canGrow: ['Tree', 'Bush', 'Grass'] },
            { name: 'Winter', length: 90, canGrow: ['Tree', 'Bush'] }
        ];
        
        const currentSeasonIndex = ref(0);
        const dayInSeason = ref(1);
        
        const season = computed(() => seasons[currentSeasonIndex.value].name);
        const seasonLength = computed(() => seasons[currentSeasonIndex.value].length);
        const totalDays = computed(() => day.value);
        
        const activePlantsCount = computed(() => {
            return plants.value.filter(p => !p.isDormant).length;
        });

        const isPositionOccupied = (x, y, size, plantsArray) => {
            return plantsArray.some(plant => {
                const distance = Math.sqrt(
                    Math.pow(plant.x - x, 2) + 
                    Math.pow(plant.y - y, 2)
                );
                return distance < (plant.size + size) / 2 + 10;
            });
        };
        
        // Параметры растений
        const plantTypes = [
            { 
                name: 'Tree', 
                color: '#27ae60', 
                growthRate: 0.2,  
                aggression: 0.7, 
                maxSize: 120, 
                shadeTolerance: 0.3, 
                coldResistance: 1.0,
                autumnDecay: 0,
                seasonalGrowth: true,
                immortal: true,
                reproductionRate: 0.5, 
                reproductionAge: 365,
                reproductionRadius: 60,
                initialSize: 5
            },
            { 
                name: 'Bush', 
                color: '#16a085', 
                growthRate: 0.18, 
                aggression: 0.6, 
                maxSize: 70, 
                shadeTolerance: 0.4, 
                coldResistance: 0.9,
                autumnDecay: 0,
                seasonalGrowth: true,
                immortal: true,
                reproductionRate: 0.4, 
                reproductionAge: 270,
                reproductionRadius: 40,
                initialSize: 6
            },
            { 
                name: 'Flower', 
                color: '#e74c3c', 
                growthRate: 1.5, 
                aggression: 0.3, 
                maxSize: 18, 
                shadeTolerance: 0.8, 
                coldResistance: 0.3, 
                autumnDecay: 0.7,
                seasonalGrowth: false,
                immortal: false,
                reproductionRate: 0.6,
                reproductionAge: 15,
                reproductionRadius: 20,
                respawnInSpring: true,
                respawnChance: 0.7,
                initialSize: 4,
            },
            { 
                name: 'Grass', 
                color: '#2ecc71', 
                growthRate: 1.8, 
                aggression: 0.5, 
                maxSize: 15, 
                shadeTolerance: 0.9, 
                coldResistance: 0.4, 
                autumnDecay: 0.5,
                seasonalGrowth: false,
                immortal: false,
                reproductionRate: 0.9, 
                reproductionAge: 5,
                reproductionRadius: 10,
                respawnInSpring: true,
                respawnChance: 0.95,
                initialSize: 3
            }
        ];
        
        const getPlantTooltip = (plant) => {
            let status = plant.isDormant ? 
                ((plant.type === 'Tree' || plant.type === 'Bush') ? 'Зимний покой' : 'Спящее') : 
                plant.isDying ? 'Умирает' : 'Активно';
            return `Тип: ${plant.type}\nВозраст: ${plant.age} дней\nЗдоровье: ${plant.health.toFixed(2)}\nРазмер: ${plant.size.toFixed(1)}px\nСтатус: ${status}`;
        };
        
        const calculateGrowthModifier = (plant) => {
            if (!plant.seasonalGrowth) {
                if (season.value === 'Summer') return 1.3;
                if (season.value === 'Spring') return 1.2;
                if (season.value === 'Autumn') return 0.7;
                return 0.3;
            }
            
            const seasonProgress = dayInSeason.value / seasonLength.value;
            
            if (season.value === 'Spring') {
                return 0.6 + (0.5 * seasonProgress);
            } else if (season.value === 'Summer') {
                return 1.0;
            } else if (season.value === 'Autumn') {
                return 0.8 - (0.6 * seasonProgress);
            } else {
                return 0.1;
            }
        };
        
        const updateSeason = () => {
            dayInSeason.value++;
            
            if (dayInSeason.value > seasons[currentSeasonIndex.value].length) {
                dayInSeason.value = 1;
                currentSeasonIndex.value = (currentSeasonIndex.value + 1) % seasons.length;
                
                if (currentSeasonIndex.value === 0) {
                    year.value++;
                }
            }
            
            const currentSeason = seasons[currentSeasonIndex.value];
            plants.value.forEach(plant => {
                plant.isDormant = !plant.immortal && !currentSeason.canGrow.includes(plant.type);
                
                if (!plant.immortal) {
                    if (season.value === 'Autumn' && plant.autumnDecay > 0) {
                        plant.isDying = true;
                    } else {
                        plant.isDying = false;
                    }
                    
                    if (season.value === 'Winter' && plant.coldResistance < 0.5) {
                        plant.health -= 0.05;
                    }
                }
            });
            
            if (season.value === 'Autumn') {
                autumnDecayRate.value = (dayInSeason.value / seasonLength.value) * 100;
            } else {
                autumnDecayRate.value = 0;
            }
        };
        
        const rememberDeadPlant = (plant) => {
            if (plant.respawnInSpring) {
                deadPlantsMemory.value.push({
                    type: plant.type,
                    x: plant.x,
                    y: plant.y,
                    size: plant.size,
                    respawnChance: plant.respawnChance
                });
            }
        };
        
        const respawnPlantsInSpring = () => {
            if (season.value === 'Spring' && dayInSeason.value === 1 && deadPlantsMemory.value.length > 0) {
                const newPlants = [];
                
                deadPlantsMemory.value.forEach(deadPlant => {
                    if (Math.random() < deadPlant.respawnChance && 
                        !isPositionOccupied(deadPlant.x, deadPlant.y, deadPlant.size, plants.value)) {
                        const type = plantTypes.find(t => t.name === deadPlant.type);
                        if (type) {
                            newPlants.push({
                                id: Date.now() + Math.random(),
                                x: deadPlant.x,
                                y: deadPlant.y,
                                size: type.initialSize,
                                color: type.color,
                                type: type.name,
                                growthRate: type.growthRate,
                                aggression: type.aggression,
                                maxSize: type.maxSize,
                                shadeTolerance: type.shadeTolerance,
                                coldResistance: type.coldResistance,
                                autumnDecay: type.autumnDecay,
                                seasonalGrowth: type.seasonalGrowth,
                                immortal: type.immortal,
                                reproductionRate: type.reproductionRate,
                                reproductionAge: type.reproductionAge,
                                reproductionRadius: type.reproductionRadius,
                                respawnInSpring: type.respawnInSpring,
                                respawnChance: type.respawnChance,
                                height: Math.floor(Math.random() * 3) + 1,
                                age: 0,
                                health: 0.8 + Math.random() * 0.2,
                                isDormant: false,
                                isDying: false,
                                neighborFlowerDays: 0
                            });
                        }
                    }
                });
                
                plants.value.push(...newPlants);
                deadPlantsMemory.value = deadPlantsMemory.value.filter(dp => 
                    !newPlants.some(np => np.x === dp.x && np.y === dp.y)
                );
            }
        };
        
        const addPlant = (specificType, x, y) => {
            if (!simulationArea.value) return;
            
            const areaWidth = simulationArea.value.clientWidth;
            const areaHeight = simulationArea.value.clientHeight;
            const type = specificType ? 
                plantTypes.find(t => t.name === specificType) : 
                plantTypes[Math.floor(Math.random() * plantTypes.length)];
            
            const canGrowNow = seasons[currentSeasonIndex.value].canGrow.includes(type.name);
            const size = type.initialSize;
            
            let posX, posY;
            let attempts = 0;
            const maxAttempts = 100;
            
            if (x === undefined || y === undefined) {
                do {
                    posX = Math.max(0, Math.min(areaWidth - size, Math.random() * (areaWidth - size)));
                    posY = Math.max(0, Math.min(areaHeight - size, Math.random() * (areaHeight - size)));
                    attempts++;
                } while (isPositionOccupied(posX, posY, size, plants.value) && attempts < maxAttempts);
                
                if (attempts >= maxAttempts) return;
            } else {
                posX = x;
                posY = y;
                if (isPositionOccupied(posX, posY, size, plants.value)) return;
            }
            
            plants.value.push({
                id: Date.now() + Math.random(),
                x: posX,
                y: posY,
                size: size,
                color: type.color,
                type: type.name,
                growthRate: type.growthRate,
                aggression: type.aggression,
                maxSize: type.maxSize,
                shadeTolerance: type.shadeTolerance,
                coldResistance: type.coldResistance,
                autumnDecay: type.autumnDecay,
                seasonalGrowth: type.seasonalGrowth,
                immortal: type.immortal,
                reproductionRate: type.reproductionRate,
                reproductionAge: type.reproductionAge,
                reproductionRadius: type.reproductionRadius,
                respawnInSpring: type.respawnInSpring,
                respawnChance: type.respawnChance,
                height: Math.floor(Math.random() * 3) + 1,
                age: 0,
                health: 0.8 + Math.random() * 0.2,
                isDormant: !type.immortal && !canGrowNow,
                isDying: false,
                neighborFlowerDays: 0
            });
        };
        
        const calculateLight = (plant) => {
            if (plant.isDormant) return 0;
            
            let light = season.value === 'Summer' ? 1.3 : 
                      season.value === 'Spring' ? 1.1 :
                      season.value === 'Autumn' ? 0.8 : 0.5;
            
            for (const otherPlant of plants.value) {
                if (!otherPlant.isDormant && otherPlant.height > plant.height) {
                    const distance = Math.sqrt(
                        Math.pow(plant.x - otherPlant.x, 2) + 
                        Math.pow(plant.y - otherPlant.y, 2)
                    );
                
                    if (distance < (plant.size + otherPlant.size) / 2) {
                        light -= 0.3 * (1 - plant.shadeTolerance);
                    }
                }
            }
            
            return Math.max(0.1, light);
        };
        
        const simulateDay = () => {
            day.value++;
            updateSeason();
            respawnPlantsInSpring();
            
            const areaWidth = simulationArea.value.clientWidth;
            const areaHeight = simulationArea.value.clientHeight;
            
            // Обновляем счетчик соседства цветов
            plants.value.forEach(plant => {
                if (plant.type === 'Flower' && !plant.isDormant && !plant.isDying) {
                    const neighbors = plants.value.filter(other =>
                        other.id !== plant.id &&
                        other.type === 'Flower' &&
                        !other.isDormant &&
                        !other.isDying &&
                        Math.sqrt(Math.pow(plant.x - other.x, 2) + Math.pow(plant.y - other.y, 2)) < 30
                    );
                    if (neighbors.length > 0) {
                        plant.neighborFlowerDays++;
                    } else {
                        plant.neighborFlowerDays = 0;
                    }
                } else {
                    plant.neighborFlowerDays = 0;
                }
            });
            
            // Удаляем умершие растения и запоминаем их
            plants.value.forEach(plant => {
                if (!plant.immortal && plant.health <= 0) {
                    rememberDeadPlant(plant);
                }
            });
            plants.value = plants.value.filter(p => p.immortal || p.health > 0);
            
            // Обрабатываем рост и здоровье
            for (let i = 0; i < plants.value.length; i++) {
                const plant = plants.value[i];
                plant.age++;
                
                if (plant.isDormant) {
                    if (!plant.immortal) {
                        plant.health -= 0.005;
                    }
                } else {
                    // Вычисляем перекрытие для цветов
                    let coverageFactor = 0;
                    if (plant.type === 'Flower') {
                        // Проверяем перекрытие с деревьями и кустами
                        for (const other of plants.value) {
                            if (other.id !== plant.id && (other.type === 'Tree' || other.type === 'Bush') && !other.isDormant) {
                                // Проверяем пересечение по координатам и размерам (округлим до кругов)
                                const dx = (plant.x + plant.size / 2) - (other.x + other.size / 2);
                                const dy = (plant.y + plant.size / 2) - (other.y + other.size / 2);
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const radiusSum = (plant.size + other.size) / 2;
                                if (dist < radiusSum) {
                                    // Чем меньше dist, тем сильнее перекрытие
                                    const overlap = (radiusSum - dist) / radiusSum; // от 0 до 1
                                    coverageFactor += overlap;
                                }
                            }
                        }
                        coverageFactor = Math.min(coverageFactor, 1);
                        if (coverageFactor > 0) {
                            // Уменьшаем здоровье цветка пропорционально перекрытию
                            plant.health -= 0.05 * coverageFactor;
                        }
                    }
                    
                    const light = calculateLight(plant);
                    const growthModifier = calculateGrowthModifier(plant);
                    
                    if (!plant.immortal && season.value === 'Autumn' && plant.autumnDecay > 0) {
                        const decayFactor = (dayInSeason.value / seasonLength.value) * plant.autumnDecay;
                        plant.health -= 0.02 + (0.05 * decayFactor);
                    }
                    
                    plant.health = Math.min(1.0, plant.health + 
                        0.03 * light * plant.aggression * growthModifier - 
                        0.01);
                    
                    if (plant.health > 0.5 && plant.size < plant.maxSize) {
                        const sizeFactor = (plant.type === 'Tree' || plant.type === 'Bush') ? 
                            (1 - (plant.size / plant.maxSize) * 0.5) : 1;
                        plant.size += plant.growthRate * light * growthModifier * sizeFactor;
                        plant.x = Math.max(0, Math.min(areaWidth - plant.size, plant.x));
                        plant.y = Math.max(0, Math.min(areaHeight - plant.size, plant.y));
                    }
                    
                    // Размножение деревьев и кустов
                    if ((plant.type === 'Tree' || plant.type === 'Bush') 
                        && season.value === 'Spring' 
                        && plant.age >= plant.reproductionAge 
                        && (plant.age % plant.reproductionAge === 0) 
                        && Math.random() < plant.reproductionRate 
                        && plants.value.length < 100) {
                        
                        const childrenCount = 1;
                        for (let j = 0; j < childrenCount; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 10 + Math.random() * plant.reproductionRadius;
                            const newX = Math.max(0, Math.min(
                                areaWidth - 10, 
                                plant.x + Math.cos(angle) * distance
                            ));
                            const newY = Math.max(0, Math.min(
                                areaHeight - 10, 
                                plant.y + Math.sin(angle) * distance
                            ));
                            
                            if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                                addPlant(plant.type, newX, newY);
                            }
                        }
                    }
                    // Размножение цветов и травы
                    else if ((plant.type === 'Flower' || plant.type === 'Grass') 
                        && (season.value === 'Spring' || season.value === 'Summer') 
                        && (plant.age % plant.reproductionAge === 0) 
                        && Math.random() < plant.reproductionRate 
                        && plants.value.length < 150) {
                        
                        const childrenCount = plant.type === 'Grass' ? 3 + Math.floor(Math.random() * 5) : Math.floor(Math.random() * 3) + 1;
                        for (let j = 0; j < childrenCount; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 5 + Math.random() * plant.reproductionRadius;
                            const newX = Math.max(0, Math.min(areaWidth - 10, plant.x + Math.cos(angle) * distance));
                            const newY = Math.max(0, Math.min(areaHeight - 10, plant.y + Math.sin(angle) * distance));
                            
                            if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                                addPlant(plant.type, newX, newY);
                            }
                        }
                    }
                }
            }
            
            // Размножение цветов при соседстве 3+ дней подряд
            plants.value.forEach(plant => {
                if (plant.type === 'Flower' && plant.neighborFlowerDays >= 3 && plants.value.length < 150) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 10 + Math.random() * 20;
                    const newX = Math.max(0, Math.min(areaWidth - 10, plant.x + Math.cos(angle) * distance));
                    const newY = Math.max(0, Math.min(areaHeight - 10, plant.y + Math.sin(angle) * distance));
                    
                    if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                        addPlant('Flower', newX, newY);
                        plant.neighborFlowerDays = 0;
                    }
                }
            });
            
            // Случайное появление новых растений весной и летом (кроме деревьев)
            if ((season.value === 'Spring' || season.value === 'Summer') && Math.random() < 0.2 && plants.value.length < 120) {
                const nonTreeTypes = plantTypes.filter(t => t.name !== 'Tree');
                const type = nonTreeTypes[Math.floor(Math.random() * nonTreeTypes.length)];
                addPlant(type.name);
            }
        };
        
        const startSimulation = () => {
            if (!isSimulating.value) {
                isSimulating.value = true;
                simulationInterval = setInterval(simulateDay, 500 / speed.value);
            }
        };
        
        const stopSimulation = () => {
            isSimulating.value = false;
            clearInterval(simulationInterval);
        };
        
        const changeSpeed = () => {
            const currentIndex = speedOptions.indexOf(speed.value);
            const nextIndex = (currentIndex + 1) % speedOptions.length;
            speed.value = speedOptions[nextIndex];
            
            if (isSimulating.value) {
                stopSimulation();
                startSimulation();
            }
        };
        
        const reset = () => {
            stopSimulation();
            plants.value = [];
            deadPlantsMemory.value = [];
            day.value = 0;
            year.value = 1;
            currentSeasonIndex.value = 0;
            dayInSeason.value = 1;
            autumnDecayRate.value = 0;
            speed.value = 1;
            
            // Стартовые растения: 3 дерева, 3 куста, 6 других растений
            for (let i = 0; i < 3; i++) {
                addPlant('Tree');
            }
            for (let i = 0; i < 3; i++) {
                addPlant('Bush');
            }
            const initialTypes = ['Flower', 'Grass'];
            for (let i = 0; i < 6; i++) {
                const type = initialTypes[Math.floor(Math.random() * initialTypes.length)];
                addPlant(type);
            }
        };
        
        onMounted(() => {
            reset();
        });
        
        return {
            simulationArea,
            plants,
            day,
            year,
            totalDays,
            dayInSeason,
            seasonLength,
            season,
            activePlantsCount,
            autumnDecayRate,
            isSimulating,
            speed,
            addPlant,
            getPlantTooltip,
            simulateDay,
            startSimulation,
            stopSimulation,
            changeSpeed,
            reset
        };
    }
}).mount('#app');
</script>
</body>
</html>