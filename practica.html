<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Симуляция растительного сообщества</title>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<style>
    #app {
        font-family: Arial, sans-serif;
        margin: 20px;
        position: relative;
    }
    .simulation-area {
        position: fixed;
        top: 0;
        right: 0;
        width: 1000px;
        height: 100vh;
        border: 2px solid #2c3e50;
        margin: 0;
        transition: background-color 1s ease;
        background: white;
        box-sizing: border-box;
        z-index: 1000;
        overflow: visible;
    }
    .plant {
        position: absolute;
        border-radius: 50%;
        opacity: 0.8;
        transition: all 0.5s ease;
        z-index: 1;
    }
    .controls {
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
        width: 100%;
    }
    button {
        padding: 8px 16px;
        cursor: pointer;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        transition: background 0.2s;
    }
    button:hover {
        background: #2980b9;
    }
    button:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }
    .stats {
        margin-top: 20px;
        font-size: 16px;
    }
    h1 {
        color: #2c3e50;
        font-size: 24px;
    }
    .season-display {
        font-weight: bold;
        margin-bottom: 10px;
        font-size: 18px;
    }
    .winter { background-color: #d4f1f9; }
    .spring { background-color: #e8f8f5; }
    .summer { background-color: #e8f8c1; }
    .autumn { background-color: #fdebd0; }
    .dying {
        animation: fadeOut 2s infinite alternate;
    }
    .winter-sleep {
        opacity: 0.3;
        filter: grayscale(70%);
    }
    @keyframes fadeOut {
        from { opacity: 0.8; }
        to { opacity: 0.3; }
    }
</style>
</head>
<body>
<div id="app">
    <h1>Симуляция растительного сообщества</h1>

    <div class="season-display">
        Год: {{ year }}, Сезон: {{ season }} (День {{ dayInSeason }}/{{ seasonLength }})
    </div>
    
    <div class="controls">
        <button @click="startSimulation" :disabled="isSimulating">Старт</button>
        <button @click="stopSimulation" :disabled="!isSimulating">Стоп</button>
        <button @click="changeSpeed">Скорость: {{speed}}x</button>
        <button @click="simulateDay">Симуляция 1 дня</button>
        <button @click="reset">Начать заново</button>
    </div>
    
    <div class="simulation-area" :class="season.toLowerCase()" ref="simulationArea">
        <div 
            v-for="plant in plants" 
            :key="plant.id"  
            class="plant"
            :class="{ 
                dying: plant.isDying,
                'winter-sleep': plant.isDormant
            }"
            :style="{
                left: plant.x + 'px',
                top: plant.y + 'px',
                width: plant.size + 'px',
                height: plant.size + 'px',
                backgroundColor: plant.color,
                zIndex: (plant.type === 'Flower' || plant.type === 'Grass') ? 1 : 3
            }"
        ></div>
    </div>
    
    <div class="stats">
        <p>День: {{ totalDays }} ({{ season }})</p>
        <p>Растений: {{ plants.length }} (Активных: {{ activePlantsCount }})</p>
    </div>
</div>

<script>
const { createApp, ref, computed, onMounted } = Vue;

// Класс для растений
class Plant {
    constructor(type, x, y, config) {
        this.id = Date.now() + Math.random();
        this.x = x;
        this.y = y;
        this.size = config.initialSize;
        this.color = config.color;
        this.type = type;
        this.growthRate = config.growthRate;
        this.aggression = config.aggression;
        this.maxSize = config.maxSize;
        this.shadeTolerance = config.shadeTolerance;
        this.coldResistance = config.coldResistance;
        this.autumnDecay = config.autumnDecay;
        this.seasonalGrowth = config.seasonalGrowth;
        this.immortal = config.immortal;
        this.reproductionRate = config.reproductionRate;
        this.reproductionAge = config.reproductionAge;
        this.reproductionRadius = config.reproductionRadius;
        this.respawnInSpring = config.respawnInSpring;
        this.respawnChance = config.respawnChance;
        this.height = Math.floor(Math.random() * 3) + 1;
        this.age = 0;
        this.health = 0.7 + Math.random() * 0.3;
        this.isDormant = false;
        this.isDying = false;
        this.neighborFlowerDays = 0;
    }

    // Метод для проверки, может ли растение расти в текущий сезон
    canGrowInSeason(currentSeason) {
        return !this.isDormant && !this.isDying && (this.immortal || this.health > 0);
    }

    // Метод для обновления состояния растения
    updateState(season, dayInSeason, seasonLength) {
        if (!this.immortal && this.health <= 0) {
            return false; // Растение умерло
        }

        this.age++;
        
        if (season === 'Autumn' && !this.immortal && this.autumnDecay > 0) {
            const autumnProgress = dayInSeason / seasonLength;
            const decayDamage = 0.02 + 0.15 * autumnProgress * this.autumnDecay;
            this.health -= decayDamage;
            this.isDying = true;
        } else {
            this.isDying = false;
        }

        if (season === 'Winter' && !this.immortal) {
            const winterDamage = 0.02 + (0.1 * (1 - this.coldResistance));
            this.health -= winterDamage;
        }

        return true; // Растение живо
    }

    // Метод для роста растения
    grow(light, growthModifier, areaWidth, areaHeight) {
        if (this.health > 0.5 && this.size < this.maxSize) {
            const sizeFactor = (this.type === 'Tree' || this.type === 'Bush') ? 
                (1 - (this.size / this.maxSize) * 0.5) : 1;
            this.size += this.growthRate * light * growthModifier * sizeFactor;
            this.x = Math.max(0, Math.min(areaWidth - this.size, this.x));
            this.y = Math.max(0, Math.min(areaHeight - this.size, this.y));
        }
    }
}

createApp({
    setup() {
        const simulationArea = ref(null);
        const plants = ref([]);
        const deadPlantsMemory = ref([]);
        const day = ref(0);
        const year = ref(1);
        const isSimulating = ref(false);
        let simulationInterval = null;
        const autumnDecayRate = ref(0);
        const speed = ref(1);
        const speedOptions = [1, 2, 5, 10];
        
        const seasons = [
            { name: 'Spring', length: 90, canGrow: ['Tree', 'Bush', 'Flower', 'Grass'] },
            { name: 'Summer', length: 90, canGrow: ['Tree', 'Bush', 'Flower', 'Grass'] },
            { name: 'Autumn', length: 90, canGrow: ['Tree', 'Bush', 'Grass'] },
            { name: 'Winter', length: 90, canGrow: ['Tree', 'Bush'] }
        ];
        
        const currentSeasonIndex = ref(0);
        const dayInSeason = ref(1);
        
        const season = computed(() => seasons[currentSeasonIndex.value].name);
        const seasonLength = computed(() => seasons[currentSeasonIndex.value].length);
        const totalDays = computed(() => day.value);
        
        const activePlantsCount = computed(() => {
            return plants.value.filter(p => !p.isDormant).length;
        });

        const isPositionOccupied = (x, y, size, plantsArray) => {
            for (const plant of plantsArray) {
                const distance = Math.sqrt(
                    Math.pow(plant.x - x, 2) + 
                    Math.pow(plant.y - y, 2)
                );
                if (distance < (plant.size + size) / 2 + 10) {
                    return true;
                }
            }
            return false;
        };
        
        const plantTypes = [
            { 
                name: 'Tree', 
                color: '#27ae60', 
                growthRate: 0.2,  
                aggression: 0.7, 
                maxSize: 1000, 
                shadeTolerance: 0.3, 
                coldResistance: 1.0,
                autumnDecay: 0,
                seasonalGrowth: true,
                immortal: true,
                reproductionRate: 0.5, 
                reproductionAge: 365,
                reproductionRadius: 60,
                initialSize: 5
            },
            { 
                name: 'Bush', 
                color: '#16a085', 
                growthRate: 0.15, 
                aggression: 0.6, 
                maxSize: 70, 
                shadeTolerance: 0.4, 
                coldResistance: 0.9,
                autumnDecay: 0,
                seasonalGrowth: true,
                immortal: true,
                reproductionRate: 0.4, 
                reproductionAge: 270,
                reproductionRadius: 40,
                initialSize: 6
            },
            { 
                name: 'Flower', 
                color: '#e74c3c', 
                growthRate: 1.5, 
                aggression: 0.3, 
                maxSize: 20, 
                shadeTolerance: 0.8, 
                coldResistance: 0.2,
                autumnDecay: 0.7,
                seasonalGrowth: false,
                immortal: false,
                reproductionRate: 0.3,
                reproductionAge: 15,
                reproductionRadius: 20,
                respawnInSpring: true,
                respawnChance: 0.6,
                initialSize: 4,
            },
            { 
                name: 'Grass', 
                color: '#2ecc71', 
                growthRate: 2.2,
                aggression: 0.7,
                maxSize: 10, 
                shadeTolerance: 0.9, 
                coldResistance: 0.4, 
                autumnDecay: 0.5,
                seasonalGrowth: false,
                immortal: false,
                reproductionRate: 0.9,
                reproductionAge: 3,
                reproductionRadius: 15,
                respawnInSpring: true,
                respawnChance: 0.9,
                initialSize: 3
            }
        ];
        
        const calculateGrowthModifier = (plant) => {
            if (!plant.seasonalGrowth) {
                if (season.value === 'Summer') return 1.3;
                if (season.value === 'Spring') return 1.2;
                if (season.value === 'Autumn') return 0.7;
                return 0.3;
            }
            
            const seasonProgress = dayInSeason.value / seasonLength.value;
            
            if (season.value === 'Spring') {
                return 0.6 + (0.5 * seasonProgress);
            } else if (season.value === 'Summer') {
                return 1.0;
            } else if (season.value === 'Autumn') {
                return 0.8 - (0.6 * seasonProgress);
            } else {
                return 0.1;
            }
        };
        
        const updateSeason = () => {
            dayInSeason.value++;
            
            if (dayInSeason.value > seasons[currentSeasonIndex.value].length) {
                dayInSeason.value = 1;
                currentSeasonIndex.value = (currentSeasonIndex.value + 1) % seasons.length;
                
                if (currentSeasonIndex.value === 0) {
                    year.value++;
                }
            }
            
            const currentSeason = seasons[currentSeasonIndex.value];
            plants.value.forEach(plant => {
                plant.isDormant = !currentSeason.canGrow.includes(plant.type);
            });
            
            if (season.value === 'Autumn') {
                autumnDecayRate.value = dayInSeason.value / seasonLength.value;
            } else {
                autumnDecayRate.value = 0;
            }
        };
        
        const rememberDeadPlant = (plant) => {
            if (plant.respawnInSpring) {
                deadPlantsMemory.value.push({
                    type: plant.type,
                    x: plant.x,
                    y: plant.y,
                    size: plant.size,
                    respawnChance: plant.respawnChance
                });
            }
        };
        
        const respawnPlantsInSpring = () => {
            if (season.value === 'Spring' && dayInSeason.value === 1 && deadPlantsMemory.value.length > 0) {
                const newPlants = [];
                
                deadPlantsMemory.value.forEach(deadPlant => {
                    if (Math.random() < deadPlant.respawnChance && 
                        !isPositionOccupied(deadPlant.x, deadPlant.y, deadPlant.size, plants.value)) {
                        const type = plantTypes.find(t => t.name === deadPlant.type);
                        if (type) {
                            newPlants.push(new Plant(
                                type.name,
                                deadPlant.x,
                                deadPlant.y,
                                type
                            ));
                        }
                    }
                });
                
                plants.value.push(...newPlants);
                deadPlantsMemory.value = deadPlantsMemory.value.filter(dp => 
                    !newPlants.some(np => np.x === dp.x && np.y === dp.y)
                );
            }
        };

        const addPlant = (specificType, x, y) => {
            if (!simulationArea.value || plants.value.length >= 1000) return;
            
            const areaWidth = simulationArea.value.clientWidth;
            const areaHeight = simulationArea.value.clientHeight;
            const type = specificType ? 
                plantTypes.find(t => t.name === specificType) : 
                plantTypes[Math.floor(Math.random() * plantTypes.length)];
            
            const canGrowNow = seasons[currentSeasonIndex.value].canGrow.includes(type.name);
            const size = type.initialSize;
            
            let posX, posY;
            let attempts = 0;
            const maxAttempts = 50;
            
            if (x === undefined || y === undefined) {
                do {
                    posX = Math.max(0, Math.min(areaWidth - size, Math.random() * (areaWidth - size)));
                    posY = Math.max(0, Math.min(areaHeight - size, Math.random() * (areaHeight - size)));
                    attempts++;
                } while (isPositionOccupied(posX, posY, size, plants.value) && attempts < maxAttempts);
                
                if (attempts >= maxAttempts) return;
            } else {
                posX = x;
                posY = y;
                if (isPositionOccupied(posX, posY, size, plants.value)) return;
            }
            
            plants.value.push(new Plant(
                type.name,
                posX,
                posY,
                type
            ));
            
            // Устанавливаем dormancy status после создания растения
            const newPlant = plants.value[plants.value.length - 1];
            newPlant.isDormant = !canGrowNow;
        };
        
        const calculateLight = (plant) => {
            if (plant.isDormant) return 0;
            
            let light = season.value === 'Summer' ? 1.3 : 
                      season.value === 'Spring' ? 1.1 :
                      season.value === 'Autumn' ? 0.8 : 0.5;
            
            for (const otherPlant of plants.value) {
                if (!otherPlant.isDormant && otherPlant.height > plant.height) {
                    const distance = Math.sqrt(
                        Math.pow(plant.x - otherPlant.x, 2) + 
                        Math.pow(plant.y - otherPlant.y, 2)
                    );
                
                    if (distance < (plant.size + otherPlant.size) / 2) {
                        light -= 0.4 * (1 - plant.shadeTolerance);
                    }
                }
            }
            
            return Math.max(0.1, light);
        };
        
        const simulateDay = () => {
            day.value++;
            updateSeason();
            respawnPlantsInSpring();
            
            const areaWidth = simulationArea.value.clientWidth;
            const areaHeight = simulationArea.value.clientHeight;
            
            // Обновляем состояние соседства для цветов
            plants.value.forEach(plant => {
                if (plant.type === 'Flower' && !plant.isDormant && !plant.isDying) {
                    const neighbors = plants.value.filter(other =>
                        other.id !== plant.id &&
                        other.type === 'Flower' &&
                        !other.isDormant &&
                        !other.isDying &&
                        Math.sqrt(Math.pow(plant.x - other.x, 2) + Math.pow(plant.y - other.y, 2)) < 30
                    );
                    if (neighbors.length > 0) {
                        plant.neighborFlowerDays++;
                    } else {
                        plant.neighborFlowerDays = 0;
                    }
                } else {
                    plant.neighborFlowerDays = 0;
                }
            });
            
            // Удаляем мертвые растения
            plants.value.forEach(plant => {
                if (!plant.immortal && plant.health <= 0) {
                    rememberDeadPlant(plant);
                }
            });
            plants.value = plants.value.filter(p => p.immortal || p.health > 0);
            
            // Обновляем и растем
            for (let i = 0; i < plants.value.length; i++) {
                const plant = plants.value[i];
                
                // Обновляем состояние растения
                const isAlive = plant.updateState(season.value, dayInSeason.value, seasonLength.value);
                if (!isAlive) continue;
                
                if (plant.isDormant) {
                    if (!plant.immortal) {
                        plant.health -= 0.01;
                    }
                    continue;
                }
                
                // Проверяем покрытие для травы и цветов
                let coverageFactor = 0;
                if (plant.type === 'Flower' || plant.type === 'Grass') {
                    for (const other of plants.value) {
                        if (other.id !== plant.id && (other.type === 'Tree' || other.type === 'Bush') && !other.isDormant) {
                            const dx = (plant.x + plant.size / 2) - (other.x + other.size / 2);
                            const dy = (plant.y + plant.size / 2) - (other.y + other.size / 2);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const radiusSum = (plant.size + other.size) / 2;
                            if (dist < radiusSum) {
                                const overlap = (radiusSum - dist) / radiusSum;
                                coverageFactor += overlap;
                            }
                        }
                    }
                    coverageFactor = Math.min(coverageFactor, 1);
                    if (coverageFactor > 0) {
                        plant.health -= 0.08 * coverageFactor;
                    }
                }
                
                const light = calculateLight(plant);
                const growthModifier = calculateGrowthModifier(plant);
                
                // Обновляем здоровье
                const healthChange = 0.03 * light * plant.aggression * growthModifier - 0.015;
                plant.health = Math.min(1.0, plant.health + healthChange);
                
                // Растем
                plant.grow(light, growthModifier, areaWidth, areaHeight);
                
                // Размножение
                if (plant.canGrowInSeason(season.value)) {
                    // Размножение деревьев и кустов
                    if ((plant.type === 'Tree' || plant.type === 'Bush') 
                        && season.value === 'Spring' 
                        && plant.age >= plant.reproductionAge 
                        && (plant.age % plant.reproductionAge === 0) 
                        && Math.random() < plant.reproductionRate 
                        && plants.value.length < 300) {
                        
                        const childrenCount = 1;
                        for (let j = 0; j < childrenCount; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 10 + Math.random() * plant.reproductionRadius;
                            const newX = Math.max(0, Math.min(
                                areaWidth - 10, 
                                plant.x + Math.cos(angle) * distance
                            ));
                            const newY = Math.max(0, Math.min(
                                areaHeight - 10, 
                                plant.y + Math.sin(angle) * distance
                            ));
                            
                            if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                                addPlant(plant.type, newX, newY);
                            }
                        }
                    }
                    // Размножение травы
                    else if (plant.type === 'Grass' 
                        && (season.value === 'Spring' || season.value === 'Summer') 
                        && (plant.age % plant.reproductionAge === 0) 
                        && Math.random() < plant.reproductionRate) {
                        
                        const childrenCount = Math.floor(Math.random() * 5) + 2;
                        
                        for (let j = 0; j < childrenCount; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 5 + Math.random() * plant.reproductionRadius;
                            const newX = Math.max(0, Math.min(areaWidth - 10, plant.x + Math.cos(angle) * distance));
                            const newY = Math.max(0, Math.min(areaHeight - 10, plant.y + Math.sin(angle) * distance));
                            
                            if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                                addPlant('Grass', newX, newY);
                            }
                        }
                    }
                    // Размножение цветов
                    else if (plant.type === 'Flower'
                        && (season.value === 'Spring' || season.value === 'Summer') 
                        && (plant.age % plant.reproductionAge === 0) 
                        && Math.random() < plant.reproductionRate 
                        && plants.value.length < 300) {
                        
                        const childrenCount = Math.floor(Math.random() * 2) + 1;
                        
                        for (let j = 0; j < childrenCount; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 5 + Math.random() * plant.reproductionRadius;
                            const newX = Math.max(0, Math.min(areaWidth - 10, plant.x + Math.cos(angle) * distance));
                            const newY = Math.max(0, Math.min(areaHeight - 10, plant.y + Math.sin(angle) * distance));
                            
                            if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                                addPlant('Flower', newX, newY);
                            }
                        }
                    }
                }
            }
            
            // Размножение цветов при соседстве
            if (plants.value.length < 300) {
                plants.value.forEach(plant => {
                    if (plant.type === 'Flower' && plant.neighborFlowerDays >= 3 && Math.random() < 0.5) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 10 + Math.random() * 20;
                        const newX = Math.max(0, Math.min(areaWidth - 10, plant.x + Math.cos(angle) * distance));
                        const newY = Math.max(0, Math.min(areaHeight - 10, plant.y + Math.sin(angle) * distance));
                        
                        if (!isPositionOccupied(newX, newY, 10, plants.value)) {
                            addPlant('Flower', newX, newY);
                            plant.neighborFlowerDays = 0;
                        }
                    }
                });
            }
            
            // Случайное появление новых растений весной и летом
            if ((season.value === 'Spring' || season.value === 'Summer') && 
                Math.random() < 0.1) {
                const nonTreeTypes = plantTypes.filter(t => t.name !== 'Tree');
                const type = nonTreeTypes[Math.floor(Math.random() * nonTreeTypes.length)];
                addPlant(type.name);
            }
        };
        
        const startSimulation = () => {
            if (!isSimulating.value) {
                isSimulating.value = true;
                simulationInterval = setInterval(simulateDay, 500 / speed.value);
            }
        };
        
        const stopSimulation = () => {
            isSimulating.value = false;
            clearInterval(simulationInterval);
        };
        
        const changeSpeed = () => {
            const currentIndex = speedOptions.indexOf(speed.value);
            const nextIndex = (currentIndex + 1) % speedOptions.length;
            speed.value = speedOptions[nextIndex];
            
            if (isSimulating.value) {
                stopSimulation();
                startSimulation();
            }
        };
        
        const reset = () => {
            stopSimulation();
            plants.value = [];
            deadPlantsMemory.value = [];
            day.value = 0;
            year.value = 1;
            currentSeasonIndex.value = 0;
            dayInSeason.value = 1;
            autumnDecayRate.value = 0;
            speed.value = 1;
            
            for (let i = 0; i < 3; i++) {
                addPlant('Tree');
                addPlant('Bush');
                addPlant('Flower');
                addPlant('Grass');
            }
        };
        
        onMounted(() => {
            reset();
        });
        
        return {
            simulationArea,
            plants,
            day,
            year,
            totalDays,
            dayInSeason,
            seasonLength,
            season,
            activePlantsCount,
            autumnDecayRate,
            isSimulating,
            speed,
            addPlant,
            simulateDay,
            startSimulation,
            stopSimulation,
            changeSpeed,
            reset
        };
    }
}).mount('#app');
</script>
</body>
</html>